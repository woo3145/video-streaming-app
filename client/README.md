# 클라이언트

#### react-router-dom v6.4 이후 버전 사용

https://reactrouter.com/en/main/start/overview

### 할일

- [x] 라우터 구성
- [x] 전체적인 뼈대 UI
- [x] Video Player UI
- [x] 상태관리 처리
- [x] 비디오 기능 hooks
- [x] 댓글 작성 UI
- [x] 풀스크린시 video 태그의 requestFullscreen 메소드 대신 다른 방법으로 대체
  - div 태그에도 requestFullscreen가 가능하기 때문에 fullScreen이 필요한 부분을 player로 감싸 requestFullScreen 요청
- [x] 구름 댓글 구현
- [x] 구름 댓글 개별 속도 기능
- [ ] Canvas를 이용한 구름 댓글 구현
- [ ] Canvas 기반과 DOM 기반 구름 댓글의 비교

### ☁️ 구름 댓글 구상

#### 1. 미리 구름을 그려놓은 긴 컴포넌트를 만들어서 시점에 맞게 translateX를 설정하는 방법 (legacy)

- 미리 모든 구름들을 그린 컴포넌트를 생성하여 동영상 시점에 맞게 translateX로 이동
- n초 간격으로 댓글 시작 시점이 오른쪽에서 생성되어 왼쪽 끝에 닿아야함

1. 동영상 width,height를 기준으로 CloudCommentOverlay의 크기를 결정(아마 width: videoWidth \* (videoDuration / n))
2. CloudCommentOverlay는 현재 재생시점으로 translateX를 구하여 댓글이 흐르도록 구현
3. 각 CloudComment들은 left로 100% \* (구름 출현시간/동영상 총 플레이타임) + 동영상 width 을 가짐

currentTime을 requestAniamtionFrame으로 업데이트 간격을 늘려 부드러운 애니메이션이 되도록 보완

장점

- 댓글이 엄청 많아도 계산을 한번만 하면된다.
- 상호작용 기능이 있을경우 추가하기 편하다. (흘러가는 댓글 클릭해서 추가작업 등)

단점

- **긴 동영상이면 overlayWidth값이 너무 커진다.** <- 이 문제로 Canvas 방식으로 변경함
- 브라우저가 requestAniamtionFrame으로 굉장히 빠르게 업데이트 되는 변수에 맞춰 dom을 조작해야해서 렌더링 성능에 부담이 간다.
- 새로운 기능을 추가하기 힘들다.
  - ex. 위로 흐르는 댓글, 제자리에서 몇초간 보였다 사라지는 댓글
- 브라우저마다 dom을 렌더링 하는 방식이 조금씩 달라서 의도치 않게 동작할 수 있다.

#### 2. Canvas를 이용하여 구름을 그리는 방법 (improved)

- 캔버스를 하나 그리고 currentTime이 초기화 -> 변경 될 때마다 댓글들을 루프하며 그리기 반복하기

최적화

- visibleClouds를 미리 계산해서 반복 수 줄이기
- 캔버스 컨텍스트에서 상대적으로 높은 비용이 발생하는 스타일 변경(fillStyle, font) 최소화 하기

장점

- 동영상 길이가 길어져도 동작에 영향을 끼치지 않는다.
- dom을 직접 조작하지 않고 canvas의 비트맵 기반의 처리를 하기 때문에 렌더링 성능이 향상된다.
- 브라우저가 달라도 canvas는 표준화된 동작을 하기 때문에 일관성 있게 동작한다.

단점

- 댓글이 너무 많아질경우 렌더링 성능이 저하된다. (클러스터 방식 등으로 추가 최적화 필요)
- 흘러가는 댓글과 상호작용 하는 기능을 추가하기 힘들다. (굳이 떠올려보면 일시정지 될 때 canvas상태를 그대로 dom으로 생성해서 이벤트 추가?)

### 동영상 자동재생 정책 (블로그로 이동 예정)

미디어 정책으로 인해 페이지 접속 시 바로 소리까지 미디어의 자동재생을 할 수 없다.

- 되는 경우
  - 재생 전 사용자 인터랙션이 한번이라도 일어나야함
  - 자동재생하는 미디어가 mute 상태일 경우
  - SPA의 경우 Home -> Watch 페이지 이동 시, 그전 사용자 인터랙션이 기록되어 있기 때문에 소리까지 자동재생이 가능하다.
- 안되는 경우 실험
  - 재생 후 바로 mute를 풀경우 x
  - 로드 후 setTimeout으로 재생 x
    - -> 10초를 기다려도 mouseMove를 제외한 사용자 행동이 하나라도 있어야 재생이된다.
  - Watch로 다이렉트 접속 시 Home으로 리다이렉트 했다가 Watch로 리다이렉션 setTimeout등록
    - -> Home에서 이동했다고 해도, 사용자의 인터랙션은 없기 때문에 x
  - keydown이벤트의 f5와 같은 키를 가로채서 element만 업데이트하기
    - -> 브라우저에 있는 새로고침 버튼은 결국 막지못함

#### 결론

- 브라우저들은 각자의 자동 재생 정책에 따라 자동재생을 허용한다.
- 크롬의 경우 사용자의 상호작용을 존중하여 자주 사용하는 사이트등에 자동재생 정책이 완화 될 수도 있다.
- 영상사이트의 대부분은 Home -> Watch는 거의 소리까지 자동재생이 되지만 Watch로 바로 접속할때는 브라우저에 따라 다르다.
- 모바일의 경우 대부분 배터리와 같은 문제로 막아둔다.
- 보니까 클릭 시 음소거 해제, 처음부터 일시정지 상태로 대체하여 구현하는 것 같다.
